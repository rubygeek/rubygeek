{"version":3,"file":"component_resolver.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/linker/component_resolver.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAKH;;;;;;;;GAQG;AACH;IAAA;IASA,CAAC;IARQ,kDAAgC,GACnC,4QAA4Q,CAAC;IAC1Q,2CAAyB,GAC5B,sFAAsF,CAAC;IAK7F,wBAAC;AAAD,CAAC,AATD,IASC;AATqB,yBAAiB,oBAStC,CAAA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../facade/lang';\nimport {ComponentFactory} from './component_factory';\n\n/**\n * Low-level service for loading {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * @deprecated Use {@link ComponentFactoryResolver} together with {@link\n * NgModule}.entryComponents}/{@link Component}.entryComponents or\n * {@link ANALYZE_FOR_ENTRY_COMPONENTS} provider for dynamic component creation.\n * Use {@link NgModuleFactoryLoader} for lazy loading.\n */\nexport abstract class ComponentResolver {\n  static DynamicCompilationDeprecationMsg =\n      'ComponentResolver is deprecated for dynamic compilation. Use ComponentFactoryResolver together with @NgModule/@Component.entryComponents or ANALYZE_FOR_ENTRY_COMPONENTS provider instead. For runtime compile only, you can also use Compiler.compileComponentSync/Async.';\n  static LazyLoadingDeprecationMsg =\n      'ComponentResolver is deprecated for lazy loading. Use NgModuleFactoryLoader instead.';\n\n\n  abstract resolveComponent(component: Type|string): Promise<ComponentFactory<any>>;\n  abstract clearCache(): void;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}