{"version":3,"file":"expression_converter.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/view_compiler/expression_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {BaseException} from '../facade/exceptions';\nimport {isArray, isBlank, isPresent} from '../facade/lang';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\n\nexport interface NameResolver {\n  callPipe(name: string, input: o.Expression, args: o.Expression[]): o.Expression;\n  getLocal(name: string): o.Expression;\n  createLiteralArray(values: o.Expression[]): o.Expression;\n  createLiteralMap(values: Array<Array<string|o.Expression>>): o.Expression;\n}\n\nexport class ExpressionWithWrappedValueInfo {\n  constructor(public expression: o.Expression, public needsValueUnwrapper: boolean) {}\n}\n\nexport function convertCdExpressionToIr(\n    nameResolver: NameResolver, implicitReceiver: o.Expression, expression: cdAst.AST,\n    valueUnwrapper: o.ReadVarExpr): ExpressionWithWrappedValueInfo {\n  const visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper);\n  const irAst: o.Expression = expression.visit(visitor, _Mode.Expression);\n  return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper);\n}\n\nexport function convertCdStatementToIr(\n    nameResolver: NameResolver, implicitReceiver: o.Expression, stmt: cdAst.AST): o.Statement[] {\n  const visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null);\n  let statements: o.Statement[] = [];\n  flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);\n  return statements;\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new BaseException(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new BaseException(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _map = new Map<cdAst.AST, cdAst.AST>();\n\n  public needsValueUnwrapper: boolean = false;\n\n  constructor(\n      private _nameResolver: NameResolver, private _implicitReceiver: o.Expression,\n      private _valueUnwrapper: o.ReadVarExpr) {}\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    var op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new BaseException(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this.visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    const input = this.visit(ast.exp, _Mode.Expression);\n    const args = this.visitAll(ast.args, _Mode.Expression);\n    const value = this._nameResolver.callPipe(ast.name, input, args);\n    this.needsValueUnwrapper = true;\n    return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode,\n        this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this.visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n    return o.importExpr(Identifiers.interpolate).callFn(args);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this.visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this.visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this.visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    let parts: any[] = [];\n    for (let i = 0; i < ast.keys.length; i++) {\n      parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);\n    }\n    return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.literal(ast.value));\n  }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      let result: any = null;\n      let receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        var varExpr = this._nameResolver.getLocal(ast.name);\n        if (isPresent(varExpr)) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (isBlank(result)) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this.visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      var receiver = this.visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._nameResolver.getLocal(ast.name);\n      }\n      if (isBlank(result)) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    let receiver: o.Expression = this.visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      var varExpr = this._nameResolver.getLocal(ast.name);\n      if (isPresent(varExpr)) {\n        throw new BaseException('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this.visit(ast, mode)); }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new BaseException('Quotes are not supported for evaluation!');\n  }\n\n  private visit(ast: cdAst.AST, mode: _Mode): any {\n    return (this._map.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    const condition = this.visit(leftMostSafe.receiver, mode).isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._map.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._map.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this.visit(ast, mode);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._map.delete(leftMostSafe);\n\n    // Produce the conditional\n    return condition.conditional(o.literal(null), access);\n  }\n\n  // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs be transform initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    let visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._map.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary) { return null; },\n      visitChain(ast: cdAst.Chain) { return null; },\n      visitConditional(ast: cdAst.Conditional) { return null; },\n      visitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n      visitInterpolation(ast: cdAst.Interpolation) { return null; },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n      visitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n      visitPipe(ast: cdAst.BindingPipe) { return null; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n      visitQuote(ast: cdAst.Quote) { return null; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}